# -*- coding: utf-8 -*-
# This file was *autogenerated* from the file ../../Sage/dixon14.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_4 = Integer(4); _sage_const_10 = Integer(10)
import sys

#dixon14.sage

#Cherche au voisinage de sqrt(i*n)
#Le voisinage n'est pas bien parametre (lim)

#h semble beaucoup trop fort

#n est un nombre impair
#La base integre -1
#
#Le meilleur algo sans essai de filtre

lm=_sage_const_10 **_sage_const_7 
p = Integer(next_prime(randint(_sage_const_2 ,lm*_sage_const_10 **_sage_const_2 )))
q = Integer(next_prime(randint(_sage_const_2 ,lm)))

t = cputime(subprocesses=True)
n = Integer(sys.argv[_sage_const_1 ])
div = []
h = Integer(round(sqrt(exp(sqrt(log(n)*log(log(n))))).n())) # borne optimale
off = _sage_const_0 
off = off / _sage_const_2 
h = h // _sage_const_2 

#print h

tb = matrix(h,h+_sage_const_1 +off)


def tstcd(b2,li,j):
	global tb,n,div
	r = Integer(b2)
	i = _sage_const_0 
	l = []
	for el in li:
		if i == _sage_const_0  :
			if r > n / _sage_const_2  :		
				tb[_sage_const_0 ,j] = _sage_const_1 
				r = n - r
		else :
			bl = _sage_const_0 
			np = (_sage_const_0 ,_sage_const_0 )
		while (r >= el) :
			av = r
		np = r.quo_rem(el)
		if np[_sage_const_1 ] != _sage_const_0  :
			r = av
			break
		else:
			r = np[_sage_const_0 ]
			tb[i,j]=tb[i,j]+_sage_const_1 
			if bl == _sage_const_0  :
				l.append(i)
				bl = _sage_const_1 
		i = i + _sage_const_1 
	if r != _sage_const_1  :
		for i in l :
			tb[i,j] = _sage_const_0 
		return -_sage_const_1 
	else:
		return _sage_const_0 

def factorDixon(n,h) :
	global tb,li,off,div
	if gcd(_sage_const_2 ,n) != _sage_const_1  :
		return _sage_const_2 
	li = [-_sage_const_1 ,_sage_const_2 ]
	a = _sage_const_3 
	i=_sage_const_2 
	while i < h :
		if gcd(a,n) == a : 
				#print 'TROUVEa'
				#print "facteurs a : ", a
				div.append(a)
				return a
	if n.jacobi(a) == _sage_const_1 :
		li.append(a)
		i = i+_sage_const_1 
		a = next_prime(a)
	#print "li : ", li
	N = Integers(n)
	j = _sage_const_0 
	liB = []
	nn = n.ndigits()
	if nn % _sage_const_2  == _sage_const_0  :
		nn = nn / _sage_const_2 +_sage_const_1 
	else :
		nn = (nn+_sage_const_1 ) / _sage_const_2 
	strt = ceil(sqrt(n,prec=_sage_const_4 *nn))

	rd = strt
	r = _sage_const_0 
	s = _sage_const_1 
	boo = _sage_const_1 
	lim = n // _sage_const_10 
	#print "lim : ",lim
	lam = lim
	while j < h+_sage_const_1 +off and s < n-_sage_const_1  :
		if r == lam :
			s = s + _sage_const_1 
			rd = ceil(sqrt(s*n,prec=_sage_const_4 *nn))
			#print "s : ", s
			r = _sage_const_0 
			lam = lim // s**_sage_const_2 
		if boo == _sage_const_0  :
			b = N(rd+r)
		else :
			b = N(rd-r)
		gc = gcd(Integer(b),n)
		if gc != _sage_const_1 :
			#print 'TROUVEb'
			#print "facteur b : gcd", gc
			#div.append(gc)
			return gc
		b2 = b * b
		ret = tstcd(b2,li,j)
		if ret == _sage_const_0  :
			#print 'AAAAA',r
			if boo == _sage_const_0  :
				liB.append(rd+r)
			else:
				liB.append(rd-r)
			j = j+_sage_const_1 
		if boo == _sage_const_1  :
			r = r+_sage_const_1 
			boo = _sage_const_0 
		else:
			boo = _sage_const_1 
	return liB

def tstcd2(bl,h) :
	global tb, div
	for i in range(h) :
		ret = sum(tb[i,j] for j in bl) % _sage_const_2 
		if ret != _sage_const_0 :
			#div.append(ret)
			return ret
	return _sage_const_0 

def searchRoot(n,liB,h):
	global tb,off, div

	ma = matrix(GF(_sage_const_2 ),map(lambda t:t%_sage_const_2 ,tb))
	mbl = (ma.right_kernel()).basis()
	for i in range(len(mbl)) :
		bl = []
		#print "mbl[",i,"] : ",mbl[i]
		for j in range(len(mbl[i])):
			if (mbl[i])[j] == _sage_const_1 :
				bl.append(j)
				ret1 = cgr(n,liB,bl)
				if ret1!=-_sage_const_1 :
					#print "bl : (searchroot) : ",bl
					div.append(ret1) 
					return ret1
				#else:
					#print "bl : (searchroot) : ",bl
					#print'CONTINUE'
	return -_sage_const_1 

li = []
liB = factorDixon(n,h)
#print 'liB : ', liB
def cgr(n,liB,res1):
	global li,tb, div

	if res1 == -_sage_const_1 :
		return -_sage_const_1 
	cg1 = _sage_const_1 
	for i in res1:
		cg1 *= liB[i] % n

	cg2 = _sage_const_1 
	k = _sage_const_0 
	for i in li:
#       if i != -1:
		ad=_sage_const_0 
		for j in res1:
			ad+=tb[k,j]
		cg2 *= i ** (ad / _sage_const_2 )
		cg2 = cg2 % n
		k = k + _sage_const_1 
	ret = gcd(n,cg2 + cg1)
	if ret != n and ret != _sage_const_1  :
		#print 'TROUVE'
		#div.append(ret)
		return ret
	else:
		return -_sage_const_1 

#print tb
#print liB

div = [] 

if type(liB) == list :
		
	#print 1
	#print "tb : ",tb
	ret=searchRoot(n,liB,h)
	#print "liB : ",liB
	div.append(ret)
	#print "ret final : ", ret
	div.append(ret)
	div.append(n/ret)
else : 
	div.append(liB)
	div.append(n/liB)

print "nombre Ã  factoriser",n
print len(div)
#print "facteurs ", div
s = "facteurs"
for i in range(len(div)) : 
  s = s + ' ' + str(div[i])
print s
print "temps", cputime(t)
